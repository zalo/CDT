<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDT WebAssembly Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .result {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }
        .error {
            background: #ffe8e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #f44336;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        pre {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 14px;
        }
        .input-section {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        textarea {
            width: 100%;
            height: 100px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>CDT WebAssembly Demo</h1>
    
    <p>This demo shows how to use the CDT (Constrained Delaunay Tetrahedrization) WebAssembly bindings to generate tetrahedral meshes from triangulated surfaces.</p>
    
    <div class="input-section">
        <h3>Input Mesh</h3>
        <p>Vertices (x,y,z coordinates):</p>
        <textarea id="vertices" placeholder="Enter vertices as: x1,y1,z1,x2,y2,z2,...">0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,1,1,0,1,1</textarea>
        
        <p>Triangles (vertex indices):</p>
        <textarea id="triangles" placeholder="Enter triangles as: v1,v2,v3,v4,v5,v6,...">0,1,2,2,3,0,4,7,6,6,5,4,0,4,5,5,1,0,2,6,7,7,3,2,0,3,7,7,4,0,1,5,6,6,2,1</textarea>
        
        <div>
            <label>
                <input type="checkbox" id="addBoundingBox"> Add bounding box
            </label>
            <label>
                <input type="checkbox" id="verbose"> Verbose output
            </label>
        </div>
    </div>
    
    <div class="example">
        <h3>Quick Examples</h3>
        <button onclick="loadCube()">Load Cube</button>
        <button onclick="loadTetrahedron()">Load Tetrahedron</button>
        <button onclick="loadOctahedron()">Load Octahedron</button>
    </div>
    
    <button id="computeBtn" onclick="computeCDT()" disabled>Compute CDT</button>
    <button onclick="validateInput()">Validate Input</button>
    
    <div id="results"></div>
    
    <div class="example">
        <h3>Expected Output</h3>
        <p>When the WebAssembly module is loaded, you'll be able to:</p>
        <ul>
            <li>Input vertex coordinates and triangle indices</li>
            <li>Compute constrained Delaunay tetrahedrization</li>
            <li>See the resulting tetrahedra and any added Steiner points</li>
            <li>Validate input before processing</li>
        </ul>
        
        <p><strong>Note:</strong> This demo page shows the interface. The actual WebAssembly module would be loaded from <code>cdt.js</code> and <code>cdt.wasm</code> files generated by the build process.</p>
    </div>

    <script>
        // CDT WebAssembly module
        let CDT = null;
        
        // Load the actual WebAssembly module
        async function loadCDTModule() {
            try {
                // Load the CDT module factory
                console.log('Attempting to load CDT module from ./cdt.js');
                const module = await import('./cdt.js');
                console.log('Module loaded, available exports:', Object.keys(module));
                
                const CDTFactory = module.default;
                if (typeof CDTFactory !== 'function') {
                    throw new Error(`CDTFactory is not a function. Got ${typeof CDTFactory}. Available exports: ${Object.keys(module).join(', ')}`);
                }
                
                console.log('CDTFactory loaded, initializing WebAssembly module...');
                
                // Initialize the WebAssembly module
                CDT = await CDTFactory();
                
                document.getElementById('computeBtn').disabled = false;
                showResult('CDT module loaded successfully!', 'result');
                
                console.log('CDT module loaded, available functions:', Object.keys(CDT).filter(k => typeof CDT[k] === 'function'));
            } catch (error) {
                console.error('Failed to load CDT module:', error);
                showResult(`Failed to load CDT module: ${error.message}. Using simulated module for demo.`, 'error');
                
                // Fallback to simulated module for demo purposes
                CDT = {
                    computeCDTWithOptions: function(vertices, triangles, addBoundingBox = false, verbose = false) {
                        // Simulate computation
                        return {
                            vertices: [...vertices, 0.5, 0.5, 0.5], // Add a Steiner point
                            tetrahedra: [0, 1, 2, 8, 2, 3, 0, 8, 4, 5, 6, 8, 6, 7, 4, 8, 0, 1, 5, 8, 1, 2, 6, 8],
                            numInputVertices: vertices.length / 3,
                            numSteinerVertices: 1,
                            numTetrahedra: 6,
                            isPolyhedron: true,
                            success: true
                        };
                    },
                    validateMesh: function(vertices, triangles) {
                        return {
                            numVertices: vertices.length / 3,
                            numTriangles: triangles.length / 3,
                            valid: vertices.length % 3 === 0 && triangles.length % 3 === 0 && vertices.length > 0 && triangles.length > 0
                        };
                    }
                };
                
                document.getElementById('computeBtn').disabled = false;
            }
        }
        
        function parseNumbers(str) {
            return str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
        }
        
        function parseIntegers(str) {
            return str.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
        }
        
        function computeCDT() {
            if (!CDT) {
                showResult('CDT module not loaded', 'error');
                return;
            }
            
            const verticesStr = document.getElementById('vertices').value;
            const trianglesStr = document.getElementById('triangles').value;
            const addBoundingBox = document.getElementById('addBoundingBox').checked;
            const verbose = document.getElementById('verbose').checked;
            
            try {
                const vertices = parseNumbers(verticesStr);
                const triangles = parseIntegers(trianglesStr);
                
                if (vertices.length === 0 || triangles.length === 0) {
                    showResult('Please enter valid vertices and triangles', 'error');
                    return;
                }
                
                const result = CDT.computeCDTWithOptions(vertices, triangles, addBoundingBox, verbose);
                
                if (result.success) {
                    let output = `<h3>✓ CDT Computation Successful</h3>`;
                    output += `<p><strong>Input:</strong> ${result.numInputVertices} vertices, ${triangles.length/3} triangles</p>`;
                    output += `<p><strong>Output:</strong> ${result.vertices.length/3} vertices, ${result.numTetrahedra} tetrahedra</p>`;
                    output += `<p><strong>Steiner points added:</strong> ${result.numSteinerVertices}</p>`;
                    output += `<p><strong>Is polyhedron:</strong> ${result.isPolyhedron}</p>`;
                    
                    output += `<h4>Tetrahedra:</h4><pre>`;
                    for (let i = 0; i < result.numTetrahedra; i++) {
                        const v0 = result.tetrahedra[i * 4];
                        const v1 = result.tetrahedra[i * 4 + 1];
                        const v2 = result.tetrahedra[i * 4 + 2];
                        const v3 = result.tetrahedra[i * 4 + 3];
                        output += `Tet ${i}: [${v0}, ${v1}, ${v2}, ${v3}]\\n`;
                    }
                    output += `</pre>`;
                    
                    showResult(output, 'result');
                } else {
                    showResult('CDT computation failed', 'error');
                }
            } catch (e) {
                showResult(`Error: ${e.message}`, 'error');
            }
        }
        
        function validateInput() {
            if (!CDT) {
                showResult('CDT module not loaded', 'error');
                return;
            }
            
            const verticesStr = document.getElementById('vertices').value;
            const trianglesStr = document.getElementById('triangles').value;
            
            try {
                const vertices = parseNumbers(verticesStr);
                const triangles = parseIntegers(trianglesStr);
                
                const info = CDT.validateMesh(vertices, triangles);
                
                if (info.valid) {
                    showResult(`✓ Input is valid: ${info.numVertices} vertices, ${info.numTriangles} triangles`, 'result');
                } else {
                    showResult('✗ Input is invalid', 'error');
                }
            } catch (e) {
                showResult(`Error: ${e.message}`, 'error');
            }
        }
        
        function showResult(html, className) {
            const results = document.getElementById('results');
            results.innerHTML = `<div class="${className}">${html}</div>`;
        }
        
        function loadCube() {
            document.getElementById('vertices').value = '0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,1,1,0,1,1';
            document.getElementById('triangles').value = '0,1,2,2,3,0,4,7,6,6,5,4,0,4,5,5,1,0,2,6,7,7,3,2,0,3,7,7,4,0,1,5,6,6,2,1';
        }
        
        function loadTetrahedron() {
            document.getElementById('vertices').value = '0,0,0,1,0,0,0.5,0.866,0,0.5,0.289,0.816';
            document.getElementById('triangles').value = '0,1,2,0,2,3,1,3,2,0,3,1';
        }
        
        function loadOctahedron() {
            document.getElementById('vertices').value = '1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1';
            document.getElementById('triangles').value = '0,2,4,0,4,3,0,3,5,0,5,2,1,4,2,1,3,4,1,5,3,1,2,5';
        }
        
        // Initialize the demo
        loadCDTModule().then(() => {
            loadCube(); // Load default example
        });
    </script>
</body>
</html>
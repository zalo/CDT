<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDT WebAssembly Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .result {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }
        .error {
            background: #ffe8e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #f44336;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        pre {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 14px;
        }
        .input-section {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        textarea {
            width: 100%;
            height: 100px;
            font-family: monospace;
            font-size: 12px;
        }
        .viewer-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .viewer {
            width: 400px;
            height: 300px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .viewer h4 {
            margin: 0 0 10px 0;
            text-align: center;
            background: #eee;
            padding: 5px;
            border-radius: 3px 3px 0 0;
        }
        .viewer-canvas {
            width: 100%;
            height: calc(100% - 30px);
        }
        .file-upload {
            margin: 10px 0;
            padding: 10px;
            border: 1px dashed #ccc;
            border-radius: 5px;
            background: #fafafa;
        }
        .sample-files {
            margin: 10px 0;
        }
        .sample-files button {
            background: #2196F3;
            margin: 2px;
        }
        .sample-files button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <h1>CDT WebAssembly Demo</h1>
    
    <p>This demo shows how to use the CDT (Constrained Delaunay Tetrahedrization) WebAssembly bindings to generate tetrahedral meshes from triangulated surfaces.</p>
    
    <div class="input-section">
        <h3>Input Mesh</h3>
        <p>Vertices (x,y,z coordinates):</p>
        <textarea id="vertices" placeholder="Enter vertices as: x1,y1,z1,x2,y2,z2,...">0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,1,1,0,1,1</textarea>
        
        <p>Triangles (vertex indices):</p>
        <textarea id="triangles" placeholder="Enter triangles as: v1,v2,v3,v4,v5,v6,...">0,1,2,2,3,0,4,7,6,6,5,4,0,4,5,5,1,0,2,6,7,7,3,2,0,3,7,7,4,0,1,5,6,6,2,1</textarea>
        
        <div>
            <label>
                <input type="checkbox" id="addBoundingBox"> Add bounding box
            </label>
            <label>
                <input type="checkbox" id="verbose"> Verbose output
            </label>
        </div>
    </div>
    
    <div class="file-upload">
        <h3>Upload Custom Mesh</h3>
        <input type="file" id="meshFile" accept=".off,.obj,.ply" onchange="loadMeshFile(this.files[0])">
        <p>Supported formats: OFF, OBJ, PLY</p>
    </div>
    
    <div class="sample-files">
        <h3>Sample Files</h3>
        <button onclick="loadSampleFile('bracket.off')">Bracket</button>
        <button onclick="loadSampleFile('112544.off')">112544</button>
        <button onclick="loadSampleFile('boeing_part.off')">Boeing Part</button>
    </div>
    
    <div class="viewer-container">
        <div class="viewer">
            <h4>Input Mesh</h4>
            <div id="inputViewer" class="viewer-canvas"></div>
        </div>
        <div class="viewer">
            <h4>Output Tetrahedralization</h4>
            <div id="outputViewer" class="viewer-canvas"></div>
        </div>
    </div>
    
    <div class="example">
        <h3>Quick Examples</h3>
        <button onclick="loadCube()">Load Cube</button>
        <button onclick="loadTetrahedron()">Load Tetrahedron</button>
        <button onclick="loadOctahedron()">Load Octahedron</button>
    </div>
    
    <button id="computeBtn" onclick="computeCDT()" disabled>Compute CDT</button>
    <button onclick="validateInput()">Validate Input</button>
    
    <div id="results"></div>
    
    <div class="example">
        <h3>Expected Output</h3>
        <p>When the WebAssembly module is loaded, you'll be able to:</p>
        <ul>
            <li>Input vertex coordinates and triangle indices</li>
            <li>Compute constrained Delaunay tetrahedrization</li>
            <li>See the resulting tetrahedra and any added Steiner points</li>
            <li>Validate input before processing</li>
        </ul>
        
        <p><strong>Note:</strong> This demo page shows the interface. The actual WebAssembly module would be loaded from <code>cdt.js</code> and <code>cdt.wasm</code> files generated by the build process.</p>
    </div>

    <script>
        // Three.js viewers
        let inputViewer = null;
        let outputViewer = null;
        
        // Initialize 3D viewers
        function initializeViewers() {
            // Input mesh viewer
            const inputContainer = document.getElementById('inputViewer');
            inputViewer = new Viewer(inputContainer, 'Input Mesh');
            
            // Output tetrahedralization viewer
            const outputContainer = document.getElementById('outputViewer');
            outputViewer = new Viewer(outputContainer, 'Output Tetrahedralization');
        }
        
        class Viewer {
            constructor(container, title) {
                this.container = container;
                this.title = title;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.controls = null;
                this.mesh = null;
                
                this.init();
            }
            
            init() {
                // Setup renderer
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setClearColor(0xf0f0f0);
                this.container.appendChild(this.renderer.domElement);
                
                // Setup camera
                this.camera.position.set(2, 2, 2);
                this.camera.lookAt(0, 0, 0);
                
                // Setup controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Add grid
                const gridHelper = new THREE.GridHelper(4, 10);
                this.scene.add(gridHelper);
                
                // Start render loop
                this.animate();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            clear() {
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
            
            setMesh(vertices, triangles, isWireframe = false) {
                this.clear();
                
                if (!vertices || !triangles || vertices.length < 9 || triangles.length < 3) {
                    return;
                }
                
                const geometry = new THREE.BufferGeometry();
                
                // Convert vertices array to Float32Array
                const vertexArray = new Float32Array(vertices);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertexArray, 3));
                
                // Convert triangles to indices
                const indexArray = new Uint16Array(triangles);
                geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));
                
                // Compute normals
                geometry.computeVertexNormals();
                
                // Create material
                const material = isWireframe ? 
                    new THREE.MeshBasicMaterial({ color: 0x0066cc, wireframe: true }) :
                    new THREE.MeshLambertMaterial({ color: 0x00aa44, side: THREE.DoubleSide });
                
                // Create mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);
                
                // Center the mesh
                const box = new THREE.Box3().setFromObject(this.mesh);
                const center = box.getCenter(new THREE.Vector3());
                this.mesh.position.sub(center);
                
                // Adjust camera to fit mesh
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                this.camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
                this.controls.target.copy(new THREE.Vector3(0, 0, 0));
                this.controls.update();
            }
            
            setTetrahedralization(vertices, tetrahedra) {
                this.clear();
                
                if (!vertices || !tetrahedra || vertices.length < 12 || tetrahedra.length < 4) {
                    return;
                }
                
                const group = new THREE.Group();
                
                // Create tetrahedra as wireframes
                for (let i = 0; i < tetrahedra.length; i += 4) {
                    const v0 = tetrahedra[i] * 3;
                    const v1 = tetrahedra[i + 1] * 3;
                    const v2 = tetrahedra[i + 2] * 3;
                    const v3 = tetrahedra[i + 3] * 3;
                    
                    // Create geometry for this tetrahedron
                    const tetGeometry = new THREE.BufferGeometry();
                    const tetVertices = new Float32Array([
                        vertices[v0], vertices[v0 + 1], vertices[v0 + 2],
                        vertices[v1], vertices[v1 + 1], vertices[v1 + 2],
                        vertices[v2], vertices[v2 + 1], vertices[v2 + 2],
                        vertices[v3], vertices[v3 + 1], vertices[v3 + 2]
                    ]);
                    
                    tetGeometry.setAttribute('position', new THREE.BufferAttribute(tetVertices, 3));
                    
                    // Tetrahedron faces: 0-1-2, 0-1-3, 0-2-3, 1-2-3
                    const tetIndices = new Uint16Array([
                        0, 1, 2,
                        0, 1, 3,
                        0, 2, 3,
                        1, 2, 3
                    ]);
                    
                    tetGeometry.setIndex(new THREE.BufferAttribute(tetIndices, 1));
                    tetGeometry.computeVertexNormals();
                    
                    // Create wireframe material
                    const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x0066cc, 
                        wireframe: true,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const tetMesh = new THREE.Mesh(tetGeometry, wireframeMaterial);
                    group.add(tetMesh);
                }
                
                this.mesh = group;
                this.scene.add(this.mesh);
                
                // Center the mesh
                const box = new THREE.Box3().setFromObject(this.mesh);
                const center = box.getCenter(new THREE.Vector3());
                this.mesh.position.sub(center);
                
                // Adjust camera to fit mesh
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                this.camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
                this.controls.target.copy(new THREE.Vector3(0, 0, 0));
                this.controls.update();
            }
            
            resize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }
        
        // File loading functions
        function loadMeshFile(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const extension = file.name.split('.').pop().toLowerCase();
                
                let meshData = null;
                if (extension === 'off') {
                    meshData = parseOFF(content);
                } else if (extension === 'obj') {
                    meshData = parseOBJ(content);
                } else {
                    showResult('Unsupported file format', 'error');
                    return;
                }
                
                if (meshData) {
                    // Update input fields
                    document.getElementById('vertices').value = meshData.vertices.join(',');
                    document.getElementById('triangles').value = meshData.triangles.join(',');
                    
                    // Update 3D viewer
                    inputViewer.setMesh(meshData.vertices, meshData.triangles);
                    
                    showResult(`Loaded ${file.name}: ${meshData.vertices.length/3} vertices, ${meshData.triangles.length/3} triangles`, 'result');
                } else {
                    showResult('Failed to parse mesh file', 'error');
                }
            };
            reader.readAsText(file);
        }
        
        function loadSampleFile(filename) {
            fetch(`Input_file/${filename}`)
                .then(response => response.text())
                .then(content => {
                    const meshData = parseOFF(content);
                    if (meshData) {
                        // Update input fields
                        document.getElementById('vertices').value = meshData.vertices.join(',');
                        document.getElementById('triangles').value = meshData.triangles.join(',');
                        
                        // Update 3D viewer
                        inputViewer.setMesh(meshData.vertices, meshData.triangles);
                        
                        showResult(`Loaded ${filename}: ${meshData.vertices.length/3} vertices, ${meshData.triangles.length/3} triangles`, 'result');
                    } else {
                        showResult(`Failed to parse ${filename}`, 'error');
                    }
                })
                .catch(error => {
                    showResult(`Failed to load ${filename}: ${error.message}`, 'error');
                });
        }
        
        // Mesh file parsers
        function parseOFF(content) {
            const lines = content.trim().split('\n');
            let lineIndex = 0;
            
            // Skip header
            if (lines[0].trim() === 'OFF') {
                lineIndex = 1;
            }
            
            // Read vertex/face counts
            const counts = lines[lineIndex].trim().split(/\s+/).map(n => parseInt(n));
            const numVertices = counts[0];
            const numFaces = counts[1];
            lineIndex++;
            
            // Read vertices
            const vertices = [];
            for (let i = 0; i < numVertices; i++) {
                const coords = lines[lineIndex + i].trim().split(/\s+/).map(n => parseFloat(n));
                vertices.push(coords[0], coords[1], coords[2]);
            }
            lineIndex += numVertices;
            
            // Read faces
            const triangles = [];
            for (let i = 0; i < numFaces; i++) {
                const face = lines[lineIndex + i].trim().split(/\s+/).map(n => parseInt(n));
                const numVerts = face[0];
                if (numVerts === 3) {
                    triangles.push(face[1], face[2], face[3]);
                } else if (numVerts === 4) {
                    // Convert quad to two triangles
                    triangles.push(face[1], face[2], face[3]);
                    triangles.push(face[1], face[3], face[4]);
                }
            }
            
            return { vertices, triangles };
        }
        
        function parseOBJ(content) {
            const lines = content.trim().split('\n');
            const vertices = [];
            const triangles = [];
            
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                } else if (parts[0] === 'f') {
                    // Handle face indices (subtract 1 for 0-based indexing)
                    const indices = parts.slice(1).map(part => parseInt(part.split('/')[0]) - 1);
                    if (indices.length === 3) {
                        triangles.push(indices[0], indices[1], indices[2]);
                    } else if (indices.length === 4) {
                        // Convert quad to two triangles
                        triangles.push(indices[0], indices[1], indices[2]);
                        triangles.push(indices[0], indices[2], indices[3]);
                    }
                }
            }
            
            return { vertices, triangles };
        }
        
        // Initialize viewers when page loads
        window.addEventListener('load', () => {
            initializeViewers();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (inputViewer) inputViewer.resize();
            if (outputViewer) outputViewer.resize();
        });
    </script>

    <script>
        // CDT WebAssembly module
        let CDT = null;
        
        // Load the actual WebAssembly module
        async function loadCDTModule() {
            try {
                // Load the CDT module factory
                console.log('Attempting to load CDT module from ./cdt.js');
                const module = await import('./cdt.js');
                console.log('Module loaded, available exports:', Object.keys(module));
                
                const CDTFactory = module.default;
                if (typeof CDTFactory !== 'function') {
                    throw new Error(`CDTFactory is not a function. Got ${typeof CDTFactory}. Available exports: ${Object.keys(module).join(', ')}`);
                }
                
                console.log('CDTFactory loaded, initializing WebAssembly module...');
                
                // Initialize the WebAssembly module
                CDT = await CDTFactory();
                
                // Test simple function first
                if (typeof CDT.testFunction === 'function') {
                    console.log('✓ testFunction is available');
                    const testResult = CDT.testFunction(3, 4);
                    console.log('testFunction(3, 4) =', testResult);
                } else {
                    console.log('✗ testFunction not found');
                }
                
                // Get debug info if available
                if (typeof CDT.debugInfo === 'function') {
                    console.log('Debug info:', CDT.debugInfo());
                }
                
                document.getElementById('computeBtn').disabled = false;
                showResult('CDT module loaded successfully!', 'result');
                
                console.log('CDT module loaded, available functions:', Object.keys(CDT).filter(k => typeof CDT[k] === 'function'));
            } catch (error) {
                console.error('Failed to load CDT module:', error);
                showResult(`Failed to load CDT module: ${error.message}. Using simulated module for demo.`, 'error');
                
                // Fallback to simulated module for demo purposes
                CDT = {
                    computeCDTWithOptions: function(vertices, triangles, addBoundingBox = false, verbose = false) {
                        // Simulate computation
                        return {
                            vertices: [...vertices, 0.5, 0.5, 0.5], // Add a Steiner point
                            tetrahedra: [0, 1, 2, 8, 2, 3, 0, 8, 4, 5, 6, 8, 6, 7, 4, 8, 0, 1, 5, 8, 1, 2, 6, 8],
                            numInputVertices: vertices.length / 3,
                            numSteinerVertices: 1,
                            numTetrahedra: 6,
                            isPolyhedron: true,
                            success: true
                        };
                    },
                    validateMesh: function(vertices, triangles) {
                        return {
                            numVertices: vertices.length / 3,
                            numTriangles: triangles.length / 3,
                            valid: vertices.length % 3 === 0 && triangles.length % 3 === 0 && vertices.length > 0 && triangles.length > 0
                        };
                    }
                };
                
                document.getElementById('computeBtn').disabled = false;
            }
        }
        
        function parseNumbers(str) {
            return str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
        }
        
        function parseIntegers(str) {
            return str.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
        }
        
        function computeCDT() {
            if (!CDT) {
                showResult('CDT module not loaded', 'error');
                return;
            }
            
            const verticesStr = document.getElementById('vertices').value;
            const trianglesStr = document.getElementById('triangles').value;
            const addBoundingBox = document.getElementById('addBoundingBox').checked;
            const verbose = document.getElementById('verbose').checked;
            
            try {
                const vertices = parseNumbers(verticesStr);
                const triangles = parseIntegers(trianglesStr);
                
                if (vertices.length === 0 || triangles.length === 0) {
                    showResult('Please enter valid vertices and triangles', 'error');
                    return;
                }
                
                // Update input viewer
                if (inputViewer) {
                    inputViewer.setMesh(vertices, triangles);
                }
                
                const result = CDT.computeCDTWithOptions(vertices, triangles, addBoundingBox, verbose);
                
                console.log('CDT computation result:', result);
                console.log('Result type:', typeof result);
                console.log('Result keys:', result ? Object.keys(result) : 'null');
                console.log('Vertices type:', typeof result?.vertices, 'length:', result?.vertices?.length);
                console.log('Tetrahedra type:', typeof result?.tetrahedra, 'length:', result?.tetrahedra?.length);
                
                if (result && result.success) {
                    let output = `<h3>✓ CDT Computation Successful</h3>`;
                    const numVertices = result.vertices && result.vertices.length ? result.vertices.length/3 : 0;
                    const numInputTriangles = triangles.length/3;
                    
                    output += `<p><strong>Input:</strong> ${result.numInputVertices || 0} vertices, ${numInputTriangles} triangles</p>`;
                    output += `<p><strong>Output:</strong> ${numVertices} vertices, ${result.numTetrahedra || 0} tetrahedra</p>`;
                    output += `<p><strong>Steiner points added:</strong> ${result.numSteinerVertices || 0}</p>`;
                    output += `<p><strong>Is polyhedron:</strong> ${result.isPolyhedron || false}</p>`;
                    
                    // Update output viewer
                    if (outputViewer && result.vertices && result.tetrahedra) {
                        outputViewer.setTetrahedralization(result.vertices, result.tetrahedra);
                    }
                    
                    if (result.tetrahedra && result.tetrahedra.length > 0) {
                        output += `<h4>Tetrahedra:</h4><pre>`;
                        const numTets = Math.min(result.numTetrahedra || 0, result.tetrahedra.length / 4);
                        for (let i = 0; i < numTets; i++) {
                            const v0 = result.tetrahedra[i * 4];
                            const v1 = result.tetrahedra[i * 4 + 1];
                            const v2 = result.tetrahedra[i * 4 + 2];
                            const v3 = result.tetrahedra[i * 4 + 3];
                            output += `Tet ${i}: [${v0}, ${v1}, ${v2}, ${v3}]\\n`;
                        }
                        output += `</pre>`;
                    } else {
                        output += `<p><strong>No tetrahedra generated</strong></p>`;
                    }
                    
                    showResult(output, 'result');
                } else {
                    const errorMsg = result ? 'CDT computation failed' : 'CDT computation returned null/undefined result';
                    showResult(errorMsg, 'error');
                }
            } catch (e) {
                showResult(`Error: ${e.message}`, 'error');
            }
        }
        
        function validateInput() {
            if (!CDT) {
                showResult('CDT module not loaded', 'error');
                return;
            }
            
            const verticesStr = document.getElementById('vertices').value;
            const trianglesStr = document.getElementById('triangles').value;
            
            try {
                const vertices = parseNumbers(verticesStr);
                const triangles = parseIntegers(trianglesStr);
                
                const info = CDT.validateMesh(vertices, triangles);
                
                if (info.valid) {
                    showResult(`✓ Input is valid: ${info.numVertices} vertices, ${info.numTriangles} triangles`, 'result');
                } else {
                    showResult('✗ Input is invalid', 'error');
                }
            } catch (e) {
                showResult(`Error: ${e.message}`, 'error');
            }
        }
        
        function showResult(html, className) {
            const results = document.getElementById('results');
            results.innerHTML = `<div class="${className}">${html}</div>`;
        }
        
        function loadCube() {
            document.getElementById('vertices').value = '0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,1,1,0,1,1';
            document.getElementById('triangles').value = '0,1,2,2,3,0,4,7,6,6,5,4,0,4,5,5,1,0,2,6,7,7,3,2,0,3,7,7,4,0,1,5,6,6,2,1';
            
            // Update 3D viewer
            if (inputViewer) {
                const vertices = parseNumbers(document.getElementById('vertices').value);
                const triangles = parseIntegers(document.getElementById('triangles').value);
                inputViewer.setMesh(vertices, triangles);
            }
        }
        
        function loadTetrahedron() {
            document.getElementById('vertices').value = '0,0,0,1,0,0,0.5,0.866,0,0.5,0.289,0.816';
            document.getElementById('triangles').value = '0,1,2,0,2,3,1,3,2,0,3,1';
            
            // Update 3D viewer
            if (inputViewer) {
                const vertices = parseNumbers(document.getElementById('vertices').value);
                const triangles = parseIntegers(document.getElementById('triangles').value);
                inputViewer.setMesh(vertices, triangles);
            }
        }
        
        function loadOctahedron() {
            document.getElementById('vertices').value = '1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1';
            document.getElementById('triangles').value = '0,2,4,0,4,3,0,3,5,0,5,2,1,4,2,1,3,4,1,5,3,1,2,5';
            
            // Update 3D viewer
            if (inputViewer) {
                const vertices = parseNumbers(document.getElementById('vertices').value);
                const triangles = parseIntegers(document.getElementById('triangles').value);
                inputViewer.setMesh(vertices, triangles);
            }
        }
        
        // Initialize the demo
        loadCDTModule().then(() => {
            loadCube(); // Load default example
        });
    </script>
</body>
</html>